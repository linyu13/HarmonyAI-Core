import { GaussianRe, ImageDataRGBA, RGBA } from 'type';
import { image } from "@kit.ImageKit";


/**
 * è¯»å– PixelMap åˆ° RGBA buffer
 */
export async function loadImageToRGBA(filePath: string): Promise<ImageDataRGBA> {
  const imageSource = image.createImageSource(filePath);
  const pixelMap = await imageSource.createPixelMap();

  const info: image.ImageInfo = await pixelMap.getImageInfo();
  const width = info.size.width;
  const height = info.size.height;

  // åˆ›å»ºä¸€ä¸ªå­˜å‚¨åƒç´ çš„ bufferï¼ˆRGBA_8888ï¼‰
  const buffer = new Uint8Array(width * height * 4);

  // âœ… å®é™…ä» pixelMap è¯»å–åƒç´ æ•°æ®
  await pixelMap.readPixelsToBuffer(buffer.buffer);

  console.info(`PixelMap loaded: ${width}x${height}, pixelFormat=${info.pixelFormat}`);

  return { buffer, width, height, pixelMap };
}

/**
 * ç¬¬ä¸€ä¸ªå›¾åƒå¢å¼ºç®—æ³•ï¼šäº®åº¦/å¯¹æ¯”åº¦å¢å¼º
 */
export function enhanceBrightnessContrast(
  buffer: RGBA,
  width: number,
  height: number,
  alpha: number,
  beta: number
): RGBA {
  const out = new Uint8Array(buffer.length);
  const n = width * height;

  for (let i = 0; i < n; i++) {
    const r = buffer[i * 4];
    const g = buffer[i * 4 + 1];
    const b = buffer[i * 4 + 2];
    const a = buffer[i * 4 + 3];

    // ğŸ”¸äº®åº¦å¯¹æ¯”åº¦å…¬å¼ï¼ˆå¸¸è§„å†™æ³•ï¼‰
    const nr = Math.min(255, Math.max(0, (r - 128) * alpha + 128 + beta));
    const ng = Math.min(255, Math.max(0, (g - 128) * alpha + 128 + beta));
    const nb = Math.min(255, Math.max(0, (b - 128) * alpha + 128 + beta));

    out[i * 4] = nr;
    out[i * 4 + 1] = ng;
    out[i * 4 + 2] = nb;
    out[i * 4 + 3] = a; // ä¿ç•™é€æ˜åº¦
  }

  return out;
}

/**
 * åˆ›å»ºæ–°çš„ç©º PixelMapï¼Œç”¨äºå†™å…¥å¢å¼ºç»“æœ
 */
export async function createEditablePixelMap(width: number, height: number): Promise<image.PixelMap> {
  const initOpts: image.InitializationOptions = {
    editable: true,
    pixelFormat: image.PixelMapFormat.RGBA_8888, // è¾“å‡º RGBA
    srcPixelFormat: image.PixelMapFormat.RGBA_8888,
    alphaType: image.AlphaType.PREMUL,
    size: { width, height },
  };

  // ç©º buffer åˆå§‹åŒ–
  const emptyBuffer = new Uint8Array(width * height * 4);
  const newPixelMap = await image.createPixelMap(emptyBuffer.buffer, initOpts);
  return newPixelMap;
}

/**
 * å°†å¢å¼ºåçš„ buffer å†™å›æ–° PixelMap
 */
export async function applyBufferToNewPixelMap(width: number, height: number, buffer: RGBA): Promise<image.PixelMap> {
  const newPixelMap = await createEditablePixelMap(width, height);

  try {
    await newPixelMap.writeBufferToPixels(buffer.buffer);
    console.info("Enhanced buffer successfully written to new PixelMap.");
  } catch (error) {
    console.error("Failed to write enhanced buffer:", error);
  }

  return newPixelMap;
}

/**
 * å®Œæ•´æµç¨‹ç¤ºä¾‹
 */
export async function GetRGBAFromPixelMap(filePath: string): Promise<ImageDataRGBA> {
  const imgData: ImageDataRGBA = await loadImageToRGBA(filePath);
  const buffer: RGBA = imgData.buffer;
  const width: number = imgData.width;
  const height: number = imgData.height;
  const pixelMap: image.PixelMap = imgData.pixelMap

  return {buffer, width, height, pixelMap};
}
export async function runFirstEnhance(filePath: string, alpha: number, beta: number): Promise<image.PixelMap> {
  // 1ï¸âƒ£ è¯»å– PixelMap å’Œ RGBA buffer
  const imgData: ImageDataRGBA = await loadImageToRGBA(filePath);
  const buffer: RGBA = imgData.buffer;
  const width: number = imgData.width;
  const height: number = imgData.height;

  // 2ï¸âƒ£ æ‰§è¡Œå¢å¼ºç®—æ³•
  const enhancedBuffer: RGBA = enhanceBrightnessContrast(buffer, width, height, alpha, beta);

  // 3ï¸âƒ£ å†™å…¥æ–° PixelMapï¼ˆä¸åœ¨åŸå›¾ä¸Šä¿®æ”¹ï¼‰
  const newPixelMap = await applyBufferToNewPixelMap(width, height, enhancedBuffer);

  // 4ï¸âƒ£ è¿”å›å¢å¼ºåçš„ PixelMap
  return newPixelMap;
}

/**
 * ä½¿ç”¨ç¤ºä¾‹
 * runFirstEnhance('/data/storage/el2/base/haps/entry/files/test.jpg', 1.5, 40)
 *   .then(pm => { /* æ˜¾ç¤º PixelMap */ /* })
 *   .catch(err => console.error(err));
 */
export function clampToU8(v: number): number {
  if (v < 0) return 0;
  if (v > 255) return 255;
  return Math.round(v);
}


export function rgbaToGrayUint8(buffer: RGBA, width: number, height: number): Uint8Array {
  const n = width * height;
  const gray = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const r = buffer[i * 4];
    const g = buffer[i * 4 + 1];
    const b = buffer[i * 4 + 2];
    gray[i] = clampToU8(0.299 * r + 0.587 * g + 0.114 * b);
  }
  return gray;
}


export function makeGaussianKernel1D(sigma: number): GaussianRe {
  const radius = Math.ceil(sigma * 3);
  const len = radius * 2 + 1;
  const kernel: number[] = new Array(len);
  const sigma2 = sigma * sigma;
  let sum = 0;
  for (let i = -radius; i <= radius; i++) {
    const v = Math.exp(-(i * i) / (2 * sigma2));
    kernel[i + radius] = v;
    sum += v;
  }
  for (let i = 0; i < len; i++) kernel[i] /= sum;
  return { kernel, radius };
}